.MODEL flat, stdcall                    ; Указывает модель памяти flat (плоская, 32-битная) и соглашение о вызовах stdcall (стандарт для Windows API).
.STACK 4096                             ; Выделяет 4096 байт для стека программы.
.DATA                                   ; Начало секции данных, где определяются переменные.
msg1            DB "Enter first operand: ", '$'  ; Строка приглашения для ввода первого операнда, '$' — признак конца строки для DOS.
msg2            DB "Enter second operand: ", '$' ; Строка приглашения для ввода второго операнда.
msg3            DB "Enter operation: ", '$'      ; Строка приглашения для ввода операции.
newline         DB 0Dh,0Ah, '$'                  ; Символы перевода строки (CR, LF) и '$' для вывода новой строки.
msg4            DB 0Dh,0Ah, "Result: ",0Dh,0Ah,'$' ; Строка для вывода результата с переводом строки.
msg5            DB 0Dh,0Ah, "Input Error",0Dh,0Ah,'$' ; Сообщение об ошибке ввода с переводом строки.
msg6            DB 0Dh,0Ah, "Overflow Error",0Dh,0Ah,'$' ; Сообщение об ошибке переполнения с переводом строки.
msg7            DB 0Dh,0Ah, "Division by Zero",0Dh,0Ah,'$' ; Сообщение об ошибке деления на ноль с переводом строки.

max_length      equ 8                   ; Константа, определяющая максимальную длину строкового ввода (8 символов).
first_operand_str  DB max_length dup('$') ; Буфер для хранения строки первого операнда, заполнен '$' длиной max_length.
second_operand_str DB max_length dup('$') ; Буфер для хранения строки второго операнда, заполнен '$' длиной max_length.
answer_str        DB 0Dh,0Ah,"+00000", '$' ; Буфер для строки результата, изначально "+00000" с переводом строки и '$'.
operation         DB 4 dup('$')         ; Буфер для символа операции, изначально заполнен '$' (4 байта).

first_operand   DW 0                    ; Переменная для хранения числового значения первого операнда (слово, 16 бит).
second_operand  DW 0                    ; Переменная для хранения числового значения второго операнда (слово, 16 бит).
ten             DW 10                   ; Константа 10 (слово), используется для преобразования строки в число.
isError         DB 0                    ; Флаг ошибки (байт), 0 — нет ошибки, 1 — ошибка ввода/переполнения, 2 — деление на ноль.
isNegative      DB 0                    ; Флаг отрицательного числа (байт), 0 — положительное, 1 — отрицательное.

.CODE                                   ; Начало секции кода программы.

str_output macro current_str            ; Определение макроса для вывода строки.
    push ax                             ; Сохранение регистра AX в стеке, чтобы не потерять его значение.
    mov ah, 09h                         ; Установка функции 09h прерывания 21h (вывод строки в DOS).
    lea dx, current_str                 ; Загрузка адреса строки current_str в регистр DX.
    int 21h                             ; Вызов прерывания 21h для вывода строки.
    pop ax                              ; Восстановление значения AX из стека.
endm                                    ; Конец определения макроса.

str_input macro current_str             ; Определение макроса для ввода строки.
    push ax                             ; Сохранение AX в стеке.
    mov ah, 0Ah                         ; Установка функции 0Ah прерывания 21h (буферизированный ввод строки).
    lea dx, current_str                 ; Загрузка адреса буфера current_str в DX.
    int 21h                             ; Вызов прерывания 21h для ввода строки с клавиатуры.
    pop ax                              ; Восстановление AX из стека.
endm                                    ; Конец макроса.

str_check macro current_str             ; Макрос для проверки и преобразования строки в число.
    local @str_is_negative, @check_plus, @shift_plus, @goNextCheck, @goCheckSign ; Локальные метки.
    local @negative, @error, @goEnd, @next_digit ; Дополнительные локальные метки.
    push bx                             ; Сохранение BX в стеке.
    push cx                             ; Сохранение CX в стеке.
    mov si, 2                           ; Установка SI на позицию 2 (начало данных после длины строки в буфере).
    xor ax, ax                          ; Обнуление AX для накопления результата.
    mov isNegative, 0                   ; Сброс флага отрицательного числа (0 — положительное).
    cmp current_str[si], '-'            ; Проверка, является ли первый символ '-'.
    je @str_is_negative                 ; Если да, переход к обработке отрицательного числа.
    cmp current_str[si], '+'            ; Проверка, является ли первый символ '+'.
    je @shift_plus                      ; Если да, переход к пропуску знака.
    jmp @goNextCheck                    ; Иначе переход к проверке цифр.

@str_is_negative:                       ; Метка для обработки отрицательного числа.
    mov isNegative, 1                   ; Установка флага отрицательного числа в 1.
    inc si                              ; Пропуск символа '-' (сдвиг указателя).
    jmp @goNextCheck                    ; Переход к проверке цифр.

@shift_plus:                            ; Метка для пропуска символа '+'.
    inc si                              ; Пропуск символа '+'.

@goNextCheck:                           ; Метка начала проверки цифр.
    xor cx, cx                          ; Обнуление CX (счетчик цифр).
@next_digit:                            ; Цикл обработки каждой цифры.
    cmp current_str[si], '$'            ; Проверка, достигнут ли конец строки ('$').
    je @goCheckSign                     ; Если да, переход к проверке знака и диапазона.
    cmp current_str[si], '0'            ; Проверка, меньше ли символ '0'.
    jl @error                           ; Если да, это не цифра — ошибка.
    cmp current_str[si], '9'            ; Проверка, больше ли символ '9'.
    jg @error                           ; Если да, это не цифра — ошибка.
    inc cx                              ; Увеличение счетчика цифр.
    cmp cx, 5                           ; Проверка, не превышает ли число цифр 5 (ограничение).
    jg @error                           ; Если больше 5, ошибка.
    mul ten                             ; Умножение текущего значения AX на 10.
    jo @error                           ; Если произошло переполнение, переход к ошибке.
    mov bx, 0                           ; Обнуление BX.
    mov bl, current_str[si]             ; Загрузка текущего символа в BL.
    sub bl, '0'                         ; Преобразование символа в цифру (вычитание кода '0').
    add ax, bx                          ; Добавление цифры к результату в AX.
    jo @error                           ; Если переполнение, переход к ошибке.
    inc si                              ; Переход к следующему символу.
    jmp @next_digit                     ; Повтор цикла для следующей цифры.

@goCheckSign:                           ; Метка проверки знака и диапазона числа.
    cmp isNegative, 1                   ; Проверка, отрицательное ли число.
    je @negative                        ; Если да, переход к обработке отрицательного числа.
    cmp ax, 32767                       ; Проверка, не превышает ли значение максимум для 16-битного числа (32767).
    jg @error                           ; Если больше, ошибка.
    jmp @goEnd                          ; Иначе завершение.

@negative:                              ; Метка обработки отрицательного числа.
    neg ax                              ; Инверсия AX (делаем число отрицательным).
    cmp ax, -32768                      ; Проверка, не меньше ли значение минимума (-32768).
    jl @error                           ; Если меньше, ошибка.
    jmp @goEnd                          ; Завершение.

@error:                                 ; Метка обработки ошибки.
    mov isError, 1                      ; Установка флага ошибки в 1.

@goEnd:                                 ; Метка завершения макроса.
    pop cx                              ; Восстановление CX.
    pop bx                              ; Восстановление BX.
endm                                    ; Конец макроса.

str_preparation macro current_str       ; Макрос подготовки строки после ввода.
    mov si, 1                           ; Установка SI на позицию 1 (длина введенной строки в буфере).
    xor bx, bx                          ; Обнуление BX.
    mov bl, current_str[si]             ; Загрузка длины введенной строки в BL.
    add si, bx                          ; Сдвиг SI на конец введенной строки.
    inc si                              ; Увеличение SI на 1 для указания на следующий байт.
    mov current_str[si], '$'            ; Установка '$' в конец строки как терминатор.
    mov isError, 0                      ; Сброс флага ошибки.
endm                                    ; Конец макроса.

operation_add macro                     ; Макрос для операции сложения.
    local @error, @goEnd                ; Локальные метки.
    mov ax, first_operand               ; Загрузка первого операнда в AX.
    cwd                                 ; Расширение знака AX в DX:AX (хотя для 16-бит это избыточно).
    mov bx, second_operand              ; Загрузка второго операнда в BX.
    add ax, bx                          ; Сложение AX и BX.
    jo @error                           ; Если переполнение, переход к ошибке.
    jmp @goEnd                          ; Иначе завершение.
@error:                                 ; Метка ошибки.
    mov isError, 1                      ; Установка флага ошибки переполнения.
@goEnd:                                 ; Метка завершения.
endm                                    ; Конец макроса.

operation_sub macro                     ; Макрос для операции вычитания.
    local @error, @goEnd                ; Локальные метки.
    mov ax, first_operand               ; Загрузка первого операнда в AX.
    cwd                                 ; Расширение знака AX в DX:AX.
    mov bx, second_operand              ; Загрузка второго операнда в BX.
    sub ax, bx                          ; Вычитание BX из AX.
    jo @error                           ; Если переполнение, переход к ошибке.
    jmp @goEnd                          ; Завершение.
@error:                                 ; Метка ошибки.
    mov isError, 1                      ; Установка флага ошибки.
@goEnd:                                 ; Метка завершения.
endm                                    ; Конец макроса.

operation_mul macro                     ; Макрос для операции умножения.
    local @error, @goEnd                ; Локальные метки.
    mov ax, first_operand               ; Загрузка первого операнда в AX.
    cwd                                 ; Расширение знака AX в DX:AX.
    mov bx, second_operand              ; Загрузка второго операнда в BX.
    imul bx                             ; Умножение AX на BX (знаковое умножение).
    jo @error                           ; Если переполнение, переход к ошибке.
    jmp @goEnd                          ; Завершение.
@error:                                 ; Метка ошибки.
    mov isError, 1                      ; Установка флага ошибки.
@goEnd:                                 ; Метка завершения.
endm                                    ; Конец макроса.

operation_div macro                     ; Макрос для операции деления.
    local @error, @goEnd, @div_zero     ; Локальные метки.
    mov bx, second_operand              ; Загрузка второго операнда в BX (делитель).
    cmp bx, 0                           ; Проверка, равен ли делитель нулю.
    je @div_zero                        ; Если ноль, переход к ошибке деления на ноль.
    mov ax, first_operand               ; Загрузка первого операнда в AX (делимое).
    cwd                                 ; Расширение знака AX в DX:AX.
    idiv bx                             ; Деление DX:AX на BX (знаковое деление, результат в AX).
    jo @error                           ; Если переполнение, переход к ошибке.
    jmp @goEnd                          ; Завершение.
@div_zero:                              ; Метка ошибки деления на ноль.
    mov isError, 2                      ; Установка флага ошибки деления на ноль (2).
    jmp @goEnd                          ; Переход к завершению.
@error:                                 ; Метка ошибки переполнения.
    mov isError, 1                      ; Установка флага ошибки (1).
@goEnd:                                 ; Метка завершения.
endm                                    ; Конец макроса.

operation_remdiv macro                  ; Макрос для операции взятия остатка от деления.
    local @error, @goEnd, @div_zero     ; Локальные метки.
    mov bx, second_operand              ; Загрузка второго операнда в BX (делитель).
    cmp bx, 0                           ; Проверка делителя на ноль.
    je @div_zero                        ; Если ноль, переход к ошибке.
    mov ax, first_operand               ; Загрузка первого операнда в AX (делимое).
    cwd                                 ; Расширение знака AX в DX:AX.
    idiv bx                             ; Деление DX:AX на BX, остаток в DX.
    mov ax, dx                          ; Перемещение остатка из DX в AX.
    jo @error                           ; Если переполнение, переход к ошибке.
    jmp @goEnd                          ; Завершение.
@div_zero:                              ; Метка ошибки деления на ноль.
    mov isError, 2                      ; Установка флага ошибки (2).
    jmp @goEnd                          ; Переход к завершению.
@error:                                 ; Метка ошибки переполнения.
    mov isError, 1                      ; Установка флага ошибки (1).
@goEnd:                                 ; Метка завершения.
endm                                    ; Конец макроса.

convert_str_to_int macro                ; Макрос для преобразования числа в строку и вывода.
    local @skip_negative, @loop, @add_minus, @output_str ; Локальные метки.
    mov isNegative, 0                   ; Сброс флага отрицательного числа.
    cmp ax, 0                           ; Проверка, отрицательное ли число в AX.
    jge @skip_negative                  ; Если неотрицательное, пропуск обработки знака.
    mov isNegative, 1                   ; Установка флага отрицательного числа.
    neg ax                              ; Преобразование числа в положительное (инверсия).

@skip_negative:                         ; Метка пропуска обработки отрицательного числа.
    mov si, 7                           ; Установка SI на позицию 7 в answer_str (начало цифр с конца).
    mov cx, 5                           ; Установка счетчика на 5 (максимум 5 цифр).
    xor dx, dx                          ; Обнуление DX.
    mov bx, ten                         ; Загрузка значения 10 в BX для деления.

@loop:                                  ; Цикл преобразования числа в строку.
    xor dx, dx                          ; Обнуление DX перед делением.
    div bx                              ; Деление AX на 10, частное в AX, остаток в DX.
    add dl, '0'                         ; Преобразование остатка в символ (добавление кода '0').
    mov answer_str[si], dl              ; Запись символа цифры в answer_str.
    dec si                              ; Сдвиг SI влево для следующей цифры.
    loop @loop                          ; Повтор цикла, пока CX не станет 0.

    cmp isNegative, 1                   ; Проверка, отрицательное ли число.
    je @add_minus                       ; Если да, добавление минуса.
    mov answer_str[si], '+'             ; Иначе добавление плюса в начало строки.
    jmp @output_str                     ; Переход к выводу.

@add_minus:                             ; Метка добавления минуса.
    mov answer_str[si], '-'             ; Установка символа '-' в начало строки.

@output_str:                            ; Метка вывода строки.
    str_output answer_str               ; Вызов макроса для вывода строки результата.
endm                                    ; Конец макроса.

begin:                                  ; Метка начала программы.
    mov ax, @data                       ; Загрузка адреса секции данных в AX.
    mov ds, ax                          ; Установка сегментного регистра DS на секцию данных.
    mov es, ax                          ; Установка сегментного регистра ES на секцию данных.
    xor ax, ax                          ; Обнуление AX.

firstInput:                             ; Метка ввода первого операнда.
    str_output msg1                     ; Вывод приглашения для первого операнда.
    str_input first_operand_str         ; Ввод строки первого операнда.
    str_output newline                  ; Вывод перевода строки.
    str_preparation first_operand_str   ; Подготовка введенной строки (добавление '$').
    str_check first_operand_str         ; Проверка строки и преобразование в число.
    cmp isError, 1                      ; Проверка флага ошибки.
    je output_error                     ; Если ошибка, вывод сообщения об ошибке.
    mov first_operand, ax               ; Сохранение преобразованного числа в first_operand.
    jmp secondInput                     ; Переход к вводу второго операнда.

output_error:                           ; Метка вывода ошибки ввода.
    str_output msg5                     ; Вывод сообщения "Input Error".
    jmp firstInput                      ; Возврат к вводу первого операнда.

secondInput:                            ; Метка ввода второго операнда.
    str_output msg2                     ; Вывод приглашения для второго операнда.
    str_input second_operand_str        ; Ввод строки второго операнда.
    str_output newline                  ; Вывод перевода строки.
    str_preparation second_operand_str  ; Подготовка строки.
    str_check second_operand_str        ; Проверка и преобразование строки в число.
    cmp isError, 1                      ; Проверка флага ошибки.
    je _output_error                    ; Если ошибка, вывод сообщения.
    mov second_operand, ax              ; Сохранение числа в second_operand.
    jmp thirdInput                      ; Переход к вводу операции.

_output_error:                          ; Метка вывода ошибки для второго операнда.
    str_output msg5                     ; Вывод сообщения "Input Error".
    jmp secondInput                     ; Возврат к вводу второго операнда.

thirdInput:                             ; Метка ввода операции.
    str_output msg3                     ; Вывод приглашения для операции.
    str_input operation                 ; Ввод строки операции.
    str_output newline                  ; Вывод перевода строки.
    mov si, 2                           ; Установка SI на позицию 2 (символ операции в буфере).
    mov bl, operation[si]               ; Загрузка символа операции в BL.
    mov isError, 0                      ; Сброс флага ошибки.

    cmp bl, '+'                         ; Проверка, является ли операция сложением.
    je _operation_add                   ; Если да, переход к сложению.
    cmp bl, '-'                         ; Проверка, является ли операция вычитанием.
    je _operation_sub                   ; Если да, переход к вычитанию.
    cmp bl, '*'                         ; Проверка, является ли операция умножением.
    je _operation_mul                   ; Если да, переход к умножению.
    cmp bl, '/'                         ; Проверка, является ли операция делением.
    je _operation_div                   ; Если да, переход к делению.
    cmp bl, '%'                         ; Проверка, является ли операция взятием остатка.
    je _operation_remdiv                ; Если да, переход к остатку.
    jmp __output_error                  ; Иначе ошибка ввода операции.

_operation_add:                         ; Метка выполнения сложения.
    operation_add                       ; Вызов макроса сложения.
    jmp _check_error                    ; Переход к проверке ошибок.

_operation_sub:                         ; Метка выполнения вычитания.
    operation_sub                       ; Вызов макроса вычитания.
    jmp _check_error                    ; Переход к проверке ошибок.

_operation_mul:                         ; Метка выполнения умножения.
    operation_mul                       ; Вызов макроса умножения.
    jmp _check_error                    ; Переход к проверке ошибок.

_operation_div:                         ; Метка выполнения деления.
    operation_div                       ; Вызов макроса деления.
    jmp _check_error                    ; Переход к проверке ошибок.

_operation_remdiv:                      ; Метка выполнения взятия остатка.
    operation_remdiv                    ; Вызов макроса остатка.
    jmp _check_error                    ; Переход к проверке ошибок.

_check_error:                           ; Метка проверки ошибок после операции.
    cmp isError, 1                      ; Проверка, есть ли ошибка переполнения (1).
    je __output_overflow                ; Если да, вывод сообщения о переполнении.
    cmp isError, 2                      ; Проверка, есть ли ошибка деления на ноль (2).
    je __output_div_zero                ; Если да, вывод сообщения о делении на ноль.
    jmp _output_end_answer              ; Иначе переход к выводу результата.

__output_overflow:                      ; Метка вывода ошибки переполнения.
    str_output msg6                     ; Вывод сообщения "Overflow Error".
    jmp _goEnd                          ; Завершение программы.

__output_div_zero:                      ; Метка вывода ошибки деления на ноль.
    str_output msg7                     ; Вывод сообщения "Division by Zero".
    jmp _goEnd                          ; Завершение программы.

__output_error:                         ; Метка вывода ошибки ввода операции.
    str_output msg5                     ; Вывод сообщения "Input Error".
    jmp thirdInput                      ; Возврат к вводу операции.

_output_end_answer:                     ; Метка вывода результата.
    convert_str_to_int                  ; Преобразование результата в строку и вывод.

_goEnd:                                 ; Метка завершения программы.
    mov ah, 4Ch                         ; Установка функции 4Ch прерывания 21h (завершение программы).
    int 21h                             ; Вызов прерывания для выхода.
end begin                               ; Указание точки входа (begin) и конца программы.