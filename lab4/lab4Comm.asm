.model small          ; Указывает модель памяти "small" (один сегмент кода и данных)

.data                 ; Начало секции данных
    msg1 db 13, 10, "Start 'test.exe'$"          ; Сообщение о запуске программы test.exe, 13,10 - перевод строки
    msg2 db 13, 10, "Program start error.$"      ; Сообщение об ошибке запуска программы
    msg3 db 13, 10, "Program has been close. Press any key.$" ; Сообщение о закрытии программы и ожидании нажатия клавиши
    
    program db "test.exe", 0                     ; Имя программы для запуска (test.exe), 0 - завершающий нуль
    fileParameters db 128 dup("$")               ; Буфер для параметров файла, заполнен символами '$'
    
    bufferFile db 1                              ; Буфер для чтения одного байта из файла
    counter db 1                                 ; Счетчик для количества прочитанных символов
    
    buffer db 128 dup("$")                       ; Буфер для хранения параметров командной строки
    parameters db 128 dup("$")                   ; Буфер для хранения параметров программы
    
    endl db 10, 13, "$"                          ; Строка для перевода каретки и новой строки, завершаемая '$'
    
    notFoundFile db 10, 13, "File not found!$"   ; Сообщение об ошибке, если файл не найден
    errorNumberParameters db 13, 10, "Invalid number of parameters.$" ; Сообщение об ошибке неправильного числа параметров
    opened db 13, 10, "File has been opened.$"   ; Сообщение об успешном открытии файла
    closed db 13, 10, "File has been closed.$"   ; Сообщение об успешном закрытии файла
    
    EPB dw 0                                     ; Начало блока параметров среды (Environment Parameter Block)
    cmd_off dw offset parameters                 ; Смещение для параметров командной строки
    cmd_seg dw ?                                 ; Сегмент для параметров командной строки (будет установлен позже)
    fcb1 dd ?                                    ; Первый FCB (File Control Block), зарезервировано
    fcb2 dd ?                                    ; Второй FCB, зарезервировано

    EPB_len dw $ - EPB                           ; Длина блока EPB (разница адресов)
            
    dsize = $ - msg1                             ; Размер секции данных (разница адресов от msg1)

.stack 100h           ; Определение стека размером 100h (256 байт)

.code                 ; Начало секции кода

start:                ; Точка входа в программу
call Main             ; Вызов основной процедуры Main

Cout macro str        ; Макрос для вывода строки на экран
    mov ax, 0900h     ; Функция DOS 09h - вывод строки
    lea dx, str       ; Загрузка адреса строки в DX
    int 21h           ; Вызов прерывания DOS для вывода строки
endm Cout             ; Конец макроса

CopyParameters proc   ; Процедура копирования параметров из буфера
    mov si, 2         ; SI указывает на начало параметров в буфере (смещение 2)
    xor di, di        ; Обнуляем DI (индекс для fileParameters)
    mov fileParameters[1], 0 ; Устанавливаем второй байт fileParameters в 0
    
ForCheck:             ; Цикл проверки символов
    cmp buffer[si], 20h ; Проверка, является ли символ пробелом
    je Next           ; Если пробел, переходим к Next
    cmp buffer[si], 09h ; Проверка, является ли символ табуляцией
    je Next           ; Если табуляция, переходим к Next
    cmp buffer[si], 24h ; Проверка, является ли символ '$'
    je ExitCopyParameters ; Если '$', завершаем копирование
    cmp buffer[si], 0dh ; Проверка, является ли символ возвратом каретки
    je ExitCopyParameters ; Если возврат каретки, завершаем копирование
    jmp ForCopyParameters ; Иначе переходим к копированию символа
    
Next:                 ; Обработка пробела или табуляции
    cmp di, 0         ; Проверяем, есть ли уже скопированные символы
    jne ExitCopyParameters ; Если есть, завершаем копирование
    inc si            ; Увеличиваем индекс буфера
    jmp ForCheck      ; Возвращаемся к проверке следующего символа

ForCopyParameters:    ; Цикл копирования символов
    mov dl, buffer[si] ; Загружаем текущий символ из буфера в DL
    mov fileParameters[di], dl ; Копируем символ в fileParameters
    inc di            ; Увеличиваем индекс для fileParameters
    inc si            ; Увеличиваем индекс для буфера
    jmp ForCheck      ; Возвращаемся к проверке следующего символа   

ExitCopyParameters:   ; Завершение копирования
    inc di            ; Увеличиваем DI для завершающего нуля
    mov fileParameters[di], 0 ; Устанавливаем завершающий нуль
    ret               ; Возвращаемся из процедуры
endp CopyParameters   ; Конец процедуры

OpenFile proc         ; Процедура открытия файла
    mov ax, 3d00h     ; Функция DOS 3Dh - открытие файла, режим только чтение
    mov dx, offset fileParameters ; Указываем адрес имени файла
    int 21h           ; Вызов прерывания DOS для открытия файла
    jc ErrorOpenFile  ; Если флаг переноса установлен, произошла ошибка
    mov bx, ax        ; Сохраняем дескриптор файла в BX
    Cout opened       ; Выводим сообщение об успешном открытии файла
    call ReadFile     ; Вызываем процедуру чтения файла
    call CloseFile    ; Вызываем процедуру закрытия файла
    jmp OK            ; Переходим к успешному завершению
    
ErrorOpenFile:        ; Обработка ошибки открытия файла
    Cout notFoundFile ; Выводим сообщение о том, что файл не найден
    jmp Exit          ; Переходим к завершению программы
    
OK:                   ; Успешное завершение открытия файла
    ret               ; Возвращаемся из процедуры
endp OpenFile         ; Конец процедуры

ReadFile proc         ; Процедура чтения файла
mov si, 1             ; SI указывает на начало буфера параметров
mov counter, 1        ; Инициализируем счетчик символов значением 1
mov parameters[si], 20h ; Устанавливаем первый параметр как пробел
inc si                ; Увеличиваем индекс SI

Reading:              ; Цикл чтения файла
    mov ax, 3f00h     ; Функция DOS 3Fh - чтение из файла
    mov dx, offset bufferFile ; Указываем адрес буфера для чтения
    mov cx, 1         ; Читаем 1 байт
    int 21h           ; Вызов прерывания DOS для чтения
    cmp ax, 0         ; Проверяем, прочитано ли 0 байт (конец файла)
    je ReadingEnd     ; Если конец файла, завершаем чтение
    mov al, bufferFile ; Загружаем прочитанный байт в AL
    cmp al, 0dh       ; Проверяем, является ли байт возвратом каретки
    je NextArg        ; Если возврат каретки, переходим к следующему аргументу
    cmp al, 0ah       ; Проверяем, является ли байт переводом строки
    je Reading        ; Если перевод строки, продолжаем чтение
    mov parameters[si], al ; Сохраняем прочитанный байт в parameters
    inc si            ; Увеличиваем индекс SI
    inc counter       ; Увеличиваем счетчик символов
    jmp Reading       ; Возвращаемся к чтению следующего байта
    
NextArg:              ; Обработка возврата каретки
    mov parameters[si], ' ' ; Заменяем возврат каретки пробелом
    inc si            ; Увеличиваем индекс SI
    inc counter       ; Увеличиваем счетчик символов
    jmp Reading       ; Возвращаемся к чтению следующего байта
    
ReadingEnd:           ; Завершение чтения файла
    mov dl, counter   ; Сохраняем значение счетчика в DL
    mov parameters[0], dl ; Устанавливаем длину параметров в начало буфера
    ret               ; Возвращаемся из процедуры
endp ReadFile         ; Конец процедуры

CloseFile proc        ; Процедура закрытия файла
    mov ax, 3e00h     ; Функция DOS 3Eh - закрытие файла
    int 21h           ; Вызов прерывания DOS для закрытия файла
    Cout closed       ; Выводим сообщение об успешном закрытии файла
    ret               ; Возвращаемся из процедуры
endp CloseFile        ; Конец процедуры

CommandLine proc      ; Процедура обработки командной строки
    xor cx, cx        ; Обнуляем CX
    xor di, di        ; Обнуляем DI
    mov si, 80h       ; SI указывает на начало командной строки (смещение 80h)
    
commandLineInput:     ; Цикл чтения командной строки
    mov al, es:[si]   ; Читаем байт из командной строки
    inc si            ; Увеличиваем индекс SI
    cmp al, 0         ; Проверяем, является ли байт нулем (конец строки)
    je commandLineEnd ; Если конец строки, завершаем
    mov buffer[di], al ; Сохраняем байт в буфер
    inc di            ; Увеличиваем индекс DI
    jmp commandLineInput ; Продолжаем чтение следующего байта

commandLineEnd:       ; Завершение обработки командной строки
    ret               ; Возвращаемся из процедуры
endp CommandLine      ; Конец процедуры

StartAnotherProgram proc ; Процедура запуска другой программы
    mov ax, 4a00h     ; Функция DOS 4Ah - изменение размера блока памяти
    mov bx, ((csize/16) + 17) + ((dsize/16) + 17) + 1 ; Рассчитываем необходимый размер памяти
    int 21h           ; Вызов прерывания DOS для изменения размера памяти
    Cout msg1         ; Выводим сообщение о запуске test.exe
    Cout msg3         ; Выводим сообщение о закрытии программы
    mov ax, 0100h     ; Функция DOS 01h - ожидание нажатия клавиши
    int 21h           ; Вызов прерывания DOS
    mov ax, @data     ; Загружаем адрес сегмента данных в AX
    mov es, ax        ; Устанавливаем ES равным сегменту данных
    mov ax, 4b00h     ; Функция DOS 4Bh - запуск программы
    lea dx, program   ; Указываем адрес имени программы (test.exe)
    lea bx, EPB       ; Указываем адрес блока параметров (EPB)
    int 21h           ; Вызов прерывания DOS для запуска программы
    jb ErrorStartProgram ; Если флаг переноса установлен, произошла ошибка
    jmp Exit          ; Переходим к завершению программы
    
ErrorStartProgram:    ; Обработка ошибки запуска программы
    Cout msg2         ; Выводим сообщение об ошибке запуска
    ret               ; Возвращаемся из процедуры
endp StartAnotherProgram ; Конец процедуры

Main proc             ; Основная процедура программы
    mov ax, @data     ; Загружаем адрес сегмента данных в AX
    mov ds, ax        ; Устанавливаем DS равным сегменту данных
    mov cmd_seg, ax   ; Устанавливаем сегмент командной строки
    call CommandLine  ; Вызываем процедуру обработки командной строки
    call CopyParameters ; Вызываем процедуру копирования параметров
    cmp fileParameters[2], 24h ; Проверяем, является ли третий байт '$' (нет параметров)
    je Error          ; Если нет параметров, переходим к ошибке
    Cout fileParameters ; Выводим параметры файла
    Cout endl         ; Выводим перевод строки
    call OpenFile     ; Вызываем процедуру открытия файла
    Cout endl         ; Выводим перевод строки
    Cout endl         ; Выводим еще один перевод строки
    Cout parameters[1] ; Выводим содержимое параметров (начиная с индекса 1)
    Cout endl         ; Выводим перевод строки
    call StartAnotherProgram ; Вызываем процедуру запуска другой программы
    jmp Exit          ; Переходим к завершению программы
    
Error:                ; Обработка ошибки неправильного числа параметров
    Cout errorNumberParameters ; Выводим сообщение об ошибке
Exit:                 ; Завершение программы
    mov ax, 4c00h     ; Функция DOS 4Ch - завершение программы
    int 21h           ; Вызов прерывания DOS для завершения
endp Main             ; Конец процедуры

csize = $ - start     ; Размер секции кода (разница адресов)
end start             ; Конец программы, точка входа - start